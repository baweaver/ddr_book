== Starting Rails

To start a deep-dive the best thing to do is to start at the beginning. What
we want to learn is how Rails boots up and serves requests. In a local
development environment, on a brand new Rails application, the way to boot up
a Rails application is with this command:

----
rails s
----

If that command doesn't work for you, make sure you have installed Rails first:

----
gem install rails
----

If that command doesn't work, make sure you have installed Ruby first.

We know the general gist of what this command does: it starts a Rails server.
But what is it _really_ doing? To find out, we're going to need to run this
command in a real Rails application, so let's create one of those now and name
it inventively "init_book":

----
rails new init_book
----

Now that we have our application up, let's see what happens when we run that
`rails s` command. We'll see this output:

----
=> Booting WEBrick
=> Rails 4.2.1 application starting in development on http://localhost:3000
=> Run `rails server -h` for more startup options
=> Ctrl-C to shutdown server
[timestamp] INFO  WEBrick 1.3.1
[timestamp] INFO  ruby 2.1.5 (2014-11-13) [x86_64-darwin14.0]
[timestamp] INFO  WEBrick::HTTPServer#start: pid=9901 port=3000
----

You're probably already familiar with that output -- or something very similar
to it -- already. Of course when we go to http://localhost:3000 in our browser
we'll see the very familiar "Welcome Aboard" page.

image::ch01/images/welcome_aboard.png[]

How does this command work? We can find out on any UNIX system by running the
`which` command:

----
which rails
----

The `which` utility will tell us where a program lives in the user's `$PATH`.
If you're on Windows, you probably have something like this but we're not
Windows users, so you'll have to figure that out yourself.

On my machine, this prints out this:

----
/Users/ryanbigg/.gem/ruby/2.2.2/bin/rails
----

For you it might be something very similar, or very different. What that path
is isn't necessarily important in this case. It's good to know that the `bin`
directory was added to your `$PATH` by whatever installed Ruby for you. What
is ultimately important is what's inside that file. 

=== [somewhere]/bin/rails

Let's open this file now and see:

[source, ruby]
.[somewhere]/bin/rails
----
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application 'railties' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

version = ">= 0"

if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
  if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
    version = $1
    ARGV.shift
  end
end

gem 'railties', version
load Gem.bin_path('railties', 'rails', version)
----

This file is an executable and uses the shebang [footnote: Bash Shebang:
http://en.wikipedia.org/wiki/Shebang_%28Unix%29] to parse the remainder of the
program through a Ruby interpreter. Without this line, it would be interpreted
as whatever shell scripting language you're using. That's probably going to be
Bash unless you're one of those hipster types that use zsh.

The next non-commented thing in this file is a require to `rubygems`. This
provides us with the RubyGem classes + methods which are used later on this
file.

After that, there's a bit of a dance in order to determine if we've specified
a version for this `rails` command. What this `if ARGV.first` code does is
enable this feature:

----
rails _4.2.0_ new app
----

It allows you to load a _different_ version of Rails and run that instead of
whatever RubyGems would pick up by default. The code checks to see if the
first argument (`ARGV.first`) matches this regular expression: `/\A_(.*)_\z/`.
If it does, _and_ if that looks like a "correct" version according to RubyGems
[footnote: For what RubyGems considers a "correct" version number, read these
code comments from `Gem::Version`: http://git.io/vfs0Y], that version is used
for what comes next.

What comes next is these two lines which really kickstart the whole process:

----
gem 'railties', version
load Gem.bin_path('railties', 'rails', version)
----

If `version` has been specified, then that version of the `railties` gem will
be loaded. The final line in this file looks in the `bin` path of the specific
version of the `railties` gem and loads the `rails` script. We can find what
script that's finding by running this command:

----
ruby -rubygems -e "puts Gem.bin_path('railties', 'rails', '>=0')"
----

You can change the `>=0` to a particular version of Rails and see the path
change; providing of course that you have that specific version of the
`railties` gem installed. On my machine, this command prints out this:

----
/Users/ryanbigg/.gem/ruby/2.2.2/gems/railties-4.2.1/bin/rails
----

Let's look at what this file does.

=== [railties gem]/bin/rails

The contents of this file are this:

[source, ruby]
----
#!/usr/bin/env ruby

git_path = File.expand_path('../../../.git', __FILE__)

if File.exist?(git_path)
  railties_path = File.expand_path('../../lib', __FILE__)
  $:.unshift(railties_path)
end
require "rails/cli"
----

This file first checks to see if there's a `.git` directory three directories
up from the path where this file is. There would only be a `.git` directory if
we were attempting to use this file in a cloned version of Rails. In this
case, the `railties` gem might not be in the `$LOAD_PATH` already or if it is,
it might be a different version to the one in the repo. The code inside the
`if` here adds the `lib` directory to the beginning of the `$LOAD_PATH` using
its shorthand variant of `$:` and `unshift`. [footnote: The code inside the
`if` is not ran in a typical Rails application, but is still worth covering
for those who are curious to know what it does.]

The final line in this file requires the file `rails/cli`. The code above it
can give us some indication of where we might find it: in the `railties` gem
itself. Indeed, that is where it is. Let's move over to that file now.

=== [railties gem]/lib/rails/cli.rb

The contents of this file are:

.[railties gem]/lib/rails/cli.rb
[source, ruby]
----
require 'rails/app_rails_loader'

# If we are inside a Rails application this method performs an exec and thus
# the rest of this script is not run.
Rails::AppRailsLoader.exec_app_rails

require 'rails/ruby_version_check'
Signal.trap("INT") { puts; exit(1) }

if ARGV.first == 'plugin'
  ARGV.shift
  require 'rails/commands/plugin'
else
  require 'rails/commands/application'
end
----

The first line of this file requires `rails/app_rails_loader`, and the second
line runs a method called `Rails::AppRailsLoader.exec_app_rails` which would
seem like it has been defined in that file based on the similarity of the
class name and the filename. As the comment says, if we're inside a Rails
application this is where this file stops and `exec_app_rails` takes over.
We'll get to that in a minute. Let's see what the rest of the file has for us first.

The next line is a require to `rails/ruby_version_check` which requires this file:

[source, ruby]
.[railties gem]/lib/rails/ruby_version_check.rb
----
if RUBY_VERSION < '1.9.3'
  desc = defined?(RUBY_DESCRIPTION) ? RUBY_DESCRIPTION : "ruby #{RUBY_VERSION} (#{RUBY_RELEASE_DATE})"
  abort <<-end_message

    Rails 4 prefers to run on Ruby 2.1 or newer.

    You're running
      #{desc}

    Please upgrade to Ruby 1.9.3 or newer to continue.

  end_message
end
----

The code here checks the `RUBY_VERSION` constant defined by the Ruby
interpreter that we're using. If that is less than Ruby 1.9.3, this file will
abort the process using the `abort` method. The message it will abort with is
everything between `<<-end_message` and its counterpart, `end_message`; a
Heredoc.

This is done because there is some code in Rails which just isn't compatible
with earlier versions. Ruby 1.9.1 and Ruby 1.9.2 have been known to have
issues, and so the Rails Core Team have decided to only support Ruby 1.9.3 and
above.

[NOTE]
.Ruby 2.2.2 and up supported by Rails 5
====

In Rails 5 this version restriction will be changing to Ruby 2.2.2:
http://git.io/vflFM. Probably as an encouragement for people to upgrade their
Rubies when they upgrade their Rails versions.

====

Let's jump back to the `[railties gem]/lib/rails/cli.rb` file and the remainder of its code:

.[railties gem]/lib/rails/cli.rb
[source, ruby]
----
Signal.trap("INT") { puts; exit(1) }

if ARGV.first == 'plugin'
  ARGV.shift
  require 'rails/commands/plugin'
else
  require 'rails/commands/application'
end
----

The `Signal.trap` method here will trap an `INT` signal; typically issued by
`Command+C` or `Control+C` shortcuts. If that code encounters one of these
signals, it will `exit` with a code of `1`, indicating that the process didn't
run correctly.

The final lines for this file check if the first argument provided to the
`rails` command is "plugin". If that's the case, it will require
`rails/commands/plugin`. This would happen if you were to run the command
`rails plugin new`, for example. If the argument isn't "plugin" then it's
assumed you want to do something with the application, and
`rails/commands/application` is loaded instead.

To find out what those do, go on and explore yourself. Consider it the first
piece of homework in this book! The book will continue to focus on what
happens when we start an application, and the next step begins with the file
that we first saw required at the top of `rails/cli.rb`: `rails/app_rails_loader.rb`.

=== [railties gem]/lib/rails/app_rails_loader.rb

This file is the longest file we've seen so far. Let's look at it in parts. The first part contains this:

[source, ruby]
----
require 'pathname'

module Rails
  module AppRailsLoader
    extend self

    RUBY = Gem.ruby
    EXECUTABLES = ['bin/rails', 'script/rails']
    BUNDLER_WARNING = <<EOS
Looks like your app's ./bin/rails is a stub that was generated by Bundler.

In Rails 4, your app's bin/ directory contains executables that are versioned
like any other source code, rather than stubs that are generated on demand.

Here's how to upgrade:

  bundle config --delete bin    # Turn off Bundler's stub generator
  rake rails:update:bin         # Use the new Rails 4 executables
  git add bin                   # Add bin/ to source control

You may need to remove bin/ from your .gitignore as well.

When you install a gem whose executable you want to use in your app,
generate it and add it to source control:

  bundle binstubs some-gem-name
  git add bin/new-executable

EOS
----

This sets up a couple of constants: `RUBY`, `EXECUTABLES` and `BUNDLER_WARNING`. The `RUBY` constant defined here will be the path to the Ruby binary, which on my machine is `/Users/ryanbigg/.rubies/ruby-2.2.2/bin/ruby`. All of these constants are used in the latter half of the file, which contains the `exec_rails_app` method that was called from `rails/cli.rb`:

[source, ruby]
----
def exec_app_rails
  original_cwd = Dir.pwd

  loop do
    if exe = find_executable
      contents = File.read(exe)

      if contents =~ /(APP|ENGINE)_PATH/
        exec RUBY, exe, *ARGV
        break # non reachable, hack to be able to stub exec in the test suite
      elsif exe.end_with?('bin/rails') && contents.include?('This file was generated by Bundler')
        $stderr.puts(BUNDLER_WARNING)
        Object.const_set(:APP_PATH, File.expand_path('config/application', Dir.pwd))
        require File.expand_path('../boot', APP_PATH)
        require 'rails/commands'
        break
      end
    end

    # If we exhaust the search there is no executable, this could be a
    # call to generate a new application, so restore the original cwd.
    Dir.chdir(original_cwd) and return if Pathname.new(Dir.pwd).root?

    # Otherwise keep moving upwards in search of an executable.
    Dir.chdir('..')
  end
end

def find_executable
  EXECUTABLES.find { |exe| File.file?(exe) }
end
----

The `exec_app_rails` method is quite long! What this method will do is attempt to find one of `bin/rails` or `script/rails` at the current path, and then if it can't find it there then it will go up a directory and look there instead. When it does find one of `bin/rails` or `script/rails`, it executes it using `exec` and this code:

----
if contents =~ /(APP|ENGINE)_PATH/
  exec RUBY, exe, *ARGV
----

If this file exists and it _doesn't_ contain one of `APP_PATH` or `ENGINE_PATH`, it falls to the `elsif`:

----
elsif exe.end_with?('bin/rails') && contents.include?('This file was generated by Bundler')
  $stderr.puts(BUNDLER_WARNING)
  Object.const_set(:APP_PATH, File.expand_path('config/application', Dir.pwd))
  require File.expand_path('../boot', APP_PATH)
  require 'rails/commands'
  break
end
----

This checks if the file's path is `bin/rails`, and if the contents include a
message that indicates if it was generate by Bundler. If you run `bundle
install --binstubs`, it will override Rails's default `bin/rails` and lead
down this path. The Rails-generated version of this file contains `APP_PATH`
and code that will be used to boot our application. The `BUNDLER_WARNING`
message will tell you how to work around this problem, while the remainder of
this code will do what the proper `bin/rails` should've done in the first
place.

Let's assume the happy path here -- where you _haven't_ ran `bundle install
--binstubs`, or if you have you've fixed it up -- and move on from here. The
`exec` method has been given a path to our `bin/rails` script within our
application and will now execute that.

=== [our application]/bin/rails

This file is much shorter than the previous file, consisting of only 4 lines:

.[our application]/bin/rails
[source, ruby]
----
#!/usr/bin/env ruby
APP_PATH = File.expand_path('../../config/application', __FILE__)
require_relative '../config/boot'
require 'rails/commands'
----

Because this file has been called from `exec`, the first line in the file needs to re-establish that we're running Ruby code, and it does this with the same Shebang we saw back in our original `[somewhere]/bin/rails` -- that's the one provided by the railties gem when it's installed.

After that, it defines a constant called `APP_PATH` which will be used to indicate to Rails that we're booting an application and not an engine. The path points to `config/application.rb` in our application.

The third line requires `config/boot.rb` using `require_relative` which is one of those new-fangled Ruby 1.9 features, and the first of many reasons why `ruby_version_check.rb` exists! That file comprises of these lines:

.[our application]/config/boot.rb
[source, ruby]
----
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)

require 'bundler/setup' # Set up gems listed in the Gemfile.
----

This file configures the environment variable `BUNDLE_GEMFILE`; but only if it's not already set. The final line requires `bundler/setup`, which is responsible for enabling the `Bundler.setup` method we'll see very shortly.

The final line of `[our application]/bin/rails` will lead into where we go next: back to the Railties gem.

=== [railties gem]/lib/rails/commands.rb

This file contains:

.[railties gem]/lib/rails/commands.rb
[source, ruby]
----
ARGV << '--help' if ARGV.empty?

aliases = {
  "g"  => "generate",
  "d"  => "destroy",
  "c"  => "console",
  "s"  => "server",
  "db" => "dbconsole",
  "r"  => "runner"
}

command = ARGV.shift
command = aliases[command] || command

require 'rails/commands/commands_tasks'

Rails::CommandsTasks.new(ARGV).run_command!(command)
----

This is the file where those nice little shortcuts like `rails g` and `rails s` are defined. What this code will do is pick the first argument from `ARGV` with a quick `shift`, and then check to see if that argument has a key in the `aliases` method. If it doesn't, then it's assumed to be the command itself. So it doesn't matter if you run "rails server" or "rails s" after this point, because command will always be "server".

The next line requires `rails/commands/commands_tasks`, which is then used to run the command that we've given it.
















